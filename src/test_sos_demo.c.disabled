/*
 * Interactive SOS Demo Implementation
 * Phase 3.4.3: Interactive SOS morse code pattern with button control
 * 
 * SOS Pattern: . . . _ _ _ . . . (short-short-short long-long-long short-short-short)
 * Button press starts/stops the SOS pattern
 */

#include "component_vm_c.h"
#include "../lib/button_input/button_input.h"
#include "../lib/semihosting/semihosting.h"

// SOS Demo VM Program
// This program demonstrates an interactive SOS morse code pattern controlled by a button
void test_sos_demo_interactive() {
    debug_print_dec("=== Interactive SOS Demo Starting ===", 0);
    
    vm_state_t vm;
    vm_error_t result = vm_init(&vm);
    if (result != VM_OK) {
        debug_print_dec("VM init failed", result);
        return;
    }
    
    // Interactive SOS Program with button control
    // Pin 2 = button input, Pin 13 = LED output
    // Button press toggles SOS pattern on/off
    uint16_t sos_program[] = {
        // Setup: Configure pins
        0x1D0D,  // PIN_MODE 13 (LED output)
        0x0101,  // PUSH 1 (OUTPUT mode)
        
        0x1D02,  // PIN_MODE 2 (Button input)  
        0x0102,  // PUSH 2 (INPUT_PULLUP mode)
        
        // Main loop: Check button state and control SOS
        // Loop: Check for button press
        0x1502,  // BUTTON_PRESSED 2 (check button)
        0x3401,  // JMP_TRUE +1 (skip if not pressed)
        0x3008,  // JMP +8 (continue loop)
        
        // Button pressed - start SOS sequence
        // SOS = 3 short, 3 long, 3 short
        
        // 3 Short signals (dots)
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 400ms pause)
        0x0190,  // PUSH 400
        
        // 3 Long signals (dashes)
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 600ms)
        0x0258,  // PUSH 600
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 600ms)
        0x0258,  // PUSH 600
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 600ms)
        0x0258,  // PUSH 600
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 400ms pause)
        0x0190,  // PUSH 400
        
        // 3 Short signals (dots) again
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1700,  // DELAY 0 (pop from stack - 2000ms pause)
        0x07D0,  // PUSH 2000
        
        // End of SOS - continue loop
        0x30E0,  // JMP -32 (back to main loop)
        
        0xFF00   // HALT (should not reach here)
    };
    
    result = vm_load_program(&vm, sos_program, sizeof(sos_program) / sizeof(uint16_t));
    if (result != VM_OK) {
        debug_print_dec("SOS program load failed", result);
        return;
    }
    
    debug_print_dec("SOS program loaded successfully", sizeof(sos_program) / sizeof(uint16_t));
    
    // Simulate button press to start SOS pattern
    debug_print_dec("Simulating button press to start SOS", 0);
    mock_button_press(2);
    
    // Run program for a limited number of cycles (simulate real-time execution)
    uint32_t max_cycles = 50;
    result = vm_run(&vm, max_cycles);
    
    debug_print_dec("SOS demo execution result", result);
    debug_print_dec("SOS demo cycles executed", vm.cycle_count);
    
    // Verify the program executed some instructions
    if (vm.cycle_count > 0) {
        debug_print_dec("SOS demo executed successfully", vm.cycle_count);
    } else {
        debug_print_dec("SOS demo execution failed", 0);
    }
    
    debug_print_dec("=== Interactive SOS Demo Complete ===", 0);
}

// Simple SOS validation (non-interactive version for testing)
void test_sos_pattern_validation() {
    debug_print_dec("=== SOS Pattern Validation Test ===", 0);
    
    vm_state_t vm;
    vm_error_t result = vm_init(&vm);
    if (result != VM_OK) {
        debug_print_dec("VM init failed", result);
        return;
    }
    
    // Simple SOS pattern test (one complete sequence)
    uint16_t simple_sos[] = {
        // Setup LED pin
        0x1D0D,  // PIN_MODE 13 (LED output)
        0x0101,  // PUSH 1 (OUTPUT mode)
        
        // Short signal (dot)
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1750,  // DELAY 80ms (short blink)
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1750,  // DELAY 80ms (short pause)
        
        // Long signal (dash)
        0x100D,  // DIGITAL_WRITE 13 (LED on)
        0x0101,  // PUSH 1 (HIGH)
        0x1700,  // DELAY 0 (pop from stack - 200ms for long)
        0x00C8,  // PUSH 200
        
        0x100D,  // DIGITAL_WRITE 13 (LED off)
        0x0100,  // PUSH 0 (LOW)
        0x1750,  // DELAY 80ms (short pause)
        
        0xFF00   // HALT
    };
    
    result = vm_load_program(&vm, simple_sos, sizeof(simple_sos) / sizeof(uint16_t));
    if (result != VM_OK) {
        debug_print_dec("Simple SOS program load failed", result);
        return;
    }
    
    debug_print_dec("Simple SOS program loaded", sizeof(simple_sos) / sizeof(uint16_t));
    
    // Execute the simple SOS pattern
    result = vm_run(&vm, 20);
    
    debug_print_dec("Simple SOS execution result", result);
    debug_print_dec("Simple SOS cycles executed", vm.cycle_count);
    
    // Verify execution completed
    if (!vm.running) {
        debug_print_dec("Simple SOS completed successfully", 1);
    } else {
        debug_print_dec("Simple SOS still running", 0);
    }
    
    debug_print_dec("=== SOS Pattern Validation Complete ===", 0);
}