# Phase 4 Tooling Opportunities

## Introduction

This document outlines potential helper scripts and tooling that can significantly aid development, testing, and debugging during Phase 4, the hardware transition to the STM32G431CB. These tools complement core development tools like PlatformIO and the debugger, streamlining workflows and enabling automated testing.

## Anticipated Helper Scripts and Tools

1.  **Automated Hardware Test Runner & Output Capture Script:**
    *   **Purpose:** Automate the execution of the embedded test suite on the target hardware and capture results.
    *   **Rationale:** Essential for efficient Test-Driven Development (TDD) on hardware and supporting continuous integration/testing loops. Enables the agentic coding assistant to automatically run tests and get feedback.
    *   **Functionality:**
        *   Trigger PlatformIO build and upload for the hardware target.
        *   Optionally trigger a hardware reset.
        *   Connect to the target's debug output (e.g., Semihosting over SWD or Debug UART like USART1 on PA9/PA10).
        *   Capture output printed by the embedded tests (e.g., PASS/FAIL messages).
        *   Parse output to determine test suite status.
        *   Report results.
    *   **Implementation:** Likely Python, using PlatformIO CLI and serial communication libraries (`pyserial`) or debugger interfaces.
    *   **Tangent:** Semihosting offers a convenient way to use host PC resources (console, files) from the target via the debugger, useful for debug printfs without dedicating a UART. It relies on specific ARM instructions intercepted by the debugger.

2.  **Memory Map Analyzer Script:**
    *   **Purpose:** Provide clear analysis of firmware Flash and RAM usage from the linker `.map` file.
    *   **Rationale:** Critical for embedded systems with constrained memory. Helps monitor code (`.text`), initialized data (`.data`), and uninitialized data (`.bss`) sizes against target limits and planned memory partitions.
    *   **Functionality:**
        *   Parse the `.map` file generated by the linker (`.pio/build/<env>/firmware.map`).
        *   Calculate and summarize memory usage by section and potentially by source file or symbol.
        *   Report sizes and percentages of total Flash/RAM and defined memory regions.
    *   **Implementation:** Python script for text parsing.
    *   **Tangent:** Understanding the `.text`, `.data`, and `.bss` sections is fundamental to embedded memory management. `.text` is executable code, `.data` is initialized global/static variables stored in Flash and copied to RAM, and `.bss` is uninitialized global/static variables allocated in RAM and typically zeroed at startup.

3.  **Bootloader Trigger Script (Refined):**
    *   **Purpose:** Programmatically trigger the custom bootloader on the target board.
    *   **Rationale:** Needed to automate the bytecode upload process by signaling the board to enter bootloader mode (e.g., via a DTR pulse or serial command).
    *   **Functionality:**
        *   Open the serial port connected to the bootloader interface (e.g., USART1).
        *   Control serial control lines (like DTR) or send a specific byte sequence to trigger the bootloader.
        *   Optionally wait for a bootloader acknowledgment.
    *   **Implementation:** Python script using `pyserial`.
    *   **Tangent:** DTR and RTS are RS-232 control signals often repurposed in embedded systems for hardware control like reset or bootloader activation.

4.  **Bytecode Upload Tool:**
    *   **Purpose:** Send the compiled bytecode file to the target board via the custom bootloader protocol over UART.
    *   **Rationale:** The core tool for deploying user programs to the VM without using SWD.
    *   **Functionality:**
        *   Read bytecode file.
        *   Implement the defined UART packet protocol (sync, type, length, payload, CRC).
        *   Manage the upload sequence (erase, write chunks, verify, complete, jump).
        *   Handle bootloader responses (ACK/NACK/ERROR).
    *   **Implementation:** Python script, potentially incorporating logic from the Bootloader Trigger script.

## Conclusion

Implementing these helper scripts and tools will significantly enhance our development workflow for Phase 4. They automate repetitive tasks, provide critical insights into memory usage, and build the necessary infrastructure for bytecode deployment via the custom bootloader. Prioritizing the Hardware Test Runner and Memory Map Analyzer will be particularly beneficial in the early stages for rapid iteration and validation on physical hardware.
