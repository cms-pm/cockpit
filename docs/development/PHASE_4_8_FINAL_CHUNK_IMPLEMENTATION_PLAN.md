# Phase 4.8: SOS MVP Final Chunk Implementation Plan
**128x32 OLED + 5-Button Interface + Oracle Integration**

## **Executive Summary**

Phase 4.8 delivers SOS (Save Our Ship) MVP using hybrid VM Graphics Subsystem + u8g2 scaffold approach. Key innovation: Static text display on 128x32 OLED for status, timer-driven LED morse code for emergency signaling.

**Success Criteria**: Button press → "SOS ACTIVE" display on OLED + LED morse pattern + Oracle upload/Canopy integration

---

## **Technical Architecture Decisions**

### **Hardware Platform**
- **Target**: STM32G431CB WeAct Studio CoreBoard
- **Display**: 128x32 SSD1306 I2C OLED (PB8/PB9)
- **Input**: 5 buttons on PC0-PC4 
- **Memory**: 512-byte framebuffer (128*32/8)

### **Timer Architecture**
```c
// Interrupt Priority (lower = higher priority)
#define LED_MORSE_PRIORITY         1  // TIM6 - Critical timing
#define BUTTON_DEBOUNCE_PRIORITY   2  // TIM7 - Shared 5-button debouncing
#define USART_RX_PRIORITY         3  // Oracle protocol
#define I2C_DISPLAY_PRIORITY      4  // OLED updates
#define VM_EXECUTION_PRIORITY     5  // Lowest - can be interrupted
```

### **SOS Implementation Strategy**
- **OLED**: Static text display ("SOS ACTIVE", "EMERGENCY", "TRANSMITTING")
- **LED**: Timer-driven morse code (... --- ...) with 200ms dots, 600ms dashes
- **NO timing coordination needed** between OLED and LED

### **Library Integration**
- **PlatformIO**: `lib_deps = olikraus/U8g2@^2.35.0`
- **u8g2 Config**: `U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C` (exact match)
- **Text Handling**: Truncate at 21 characters (128px ÷ 6px font = 21 chars)

---

## **Waterfall Chunk Breakdown**

### **Chunk 4.8.1: VM Graphics Opcodes Foundation**
**Branch**: `chunk-4-8-1-vm-graphics-opcodes`  
**Duration**: 2 days  
**Dependencies**: None

**Files to Modify**:
- `lib/vm_cockpit/src/vm_opcodes.h`
- `lib/vm_compiler/src/bytecode_visitor.cpp`
- `lib/vm_cockpit/src/execution_engine.cpp`

**Implementation Tasks**:
1. Add 5 VM opcodes to reserved range 0x1B-0x1F:
   ```c
   OP_DISPLAY_CLEAR  = 0x1B,  // Clear screen buffer
   OP_DISPLAY_TEXT   = 0x1C,  // Draw text at(x,y)  
   OP_DISPLAY_UPDATE = 0x1D,  // Flush buffer to OLED
   OP_BUTTON_READ    = 0x1E,  // Read 5-button matrix
   OP_LED_MORSE      = 0x1F,  // Start LED morse pattern
   ```

2. Update `BytecodeVisitor::getArduinoOpcode()` mapping:
   ```cpp
   if (function_name == "display_clear") return VMOpcode::OP_DISPLAY_CLEAR;
   if (function_name == "display_text") return VMOpcode::OP_DISPLAY_TEXT;
   if (function_name == "display_update") return VMOpcode::OP_DISPLAY_UPDATE;
   if (function_name == "button_read") return VMOpcode::OP_BUTTON_READ;
   if (function_name == "led_morse") return VMOpcode::OP_LED_MORSE;
   ```

3. Add execution engine switch cases with placeholder implementations

**TDD Validation**:
```bash
# Test 4.8.1.1: Function compilation
echo 'void test() { display_clear(); display_text(0,0,"test"); display_update(); }' | lib/vm_compiler/tools/vm_compiler
# PASS: Generates opcodes 0x1B, 0x1C, 0x1D

# Test 4.8.1.2: Coordinate validation for 128x32
echo 'display_text(127, 31, "edge");' | lib/vm_compiler/tools/vm_compiler  # Valid
echo 'display_text(128, 32, "invalid");' | lib/vm_compiler/tools/vm_compiler  # Should warn
# PASS: Boundary validation for 128x32 display

# Test 4.8.1.3: Bytecode generation verification
lib/vm_compiler/tools/vm_compiler simple_display.c -o test.bin
hexdump test.bin | grep -E "1b00|1c00|1d00"
# PASS: All graphics opcodes present in generated bytecode
```

**Validation Gate**: All graphics functions compile to correct VM opcodes

---

### **Chunk 4.8.2: Host Interface + Timer Integration**
**Branch**: `chunk-4-8-2-host-interface-timers`  
**Duration**: 3 days  
**Dependencies**: Chunk 4.8.1 complete

**Files to Modify**:
- `lib/vm_cockpit/src/host_interface.h`
- `lib/vm_cockpit/src/host_interface.cpp` 
- `src/platform/stm32g431cb/timer_config.c`
- `lib/vm_cockpit/src/execution_engine.cpp`

**Implementation Tasks**:
1. Configure STM32G431CB interrupt priorities and timer allocation
2. Initialize TIM6 for LED morse timing, TIM7 for button debouncing
3. Implement Host Interface API:
   ```c
   void display_clear(void);
   void display_text(uint8_t x, uint8_t y, const char* text);
   void display_update(void);
   uint8_t button_read_state(void);  // Returns 5-bit button matrix
   void led_morse_start(const char* pattern);
   ```

4. Add non-blocking LED morse state machine
5. Implement shared button debouncing (20ms windows, 5 buttons)

**TDD Validation**:
```cpp
// Test 4.8.2.1: Interrupt priority verification
// Mock test - verify morse timer interrupts VM execution
uint32_t vm_interruptions = count_vm_interruptions();
led_morse_start("SOS");
execute_vm_for_3_seconds();
assert(vm_interruptions > 0);  // Higher priority morse interrupted VM
// PASS: Interrupt hierarchy working correctly

// Test 4.8.2.2: Button debouncing
// Rapid button press simulation
press_button_rapidly(0x01, 10);  // Button 1, 10 times in 100ms
uint8_t registered_presses = count_button_events();
assert(registered_presses == 1);  // Only one press registered
// PASS: Debouncing prevents multiple rapid triggers

// Test 4.8.2.3: Non-blocking LED morse
led_morse_start("... --- ...");
uint32_t start_time = millis();
while(led_morse_active()) {
    // Other work can happen here - non-blocking
    other_vm_work();
}
uint32_t duration = millis() - start_time;
assert(duration > 2400 && duration < 2600);  // SOS ~2.5 seconds
// PASS: LED morse runs non-blocking with accurate timing
```

**Validation Gate**: Timer systems coordinate without conflicts, accurate LED morse timing

---

### **Chunk 4.8.3: u8g2 Platform Integration (128x32)**  
**Branch**: `chunk-4-8-3-u8g2-platform-integration`  
**Duration**: 2 days  
**Dependencies**: Chunk 4.8.2 complete

**Files to Modify**:
- `platformio.ini`
- `src/platform/stm32g431cb/display_platform.c`
- `lib/vm_cockpit/src/host_interface.cpp` (connect to platform)

**Implementation Tasks**:
1. Add u8g2 library to PlatformIO dependencies:
   ```ini
   [env:weact_g431cb_hardware]
   lib_deps = 
       olikraus/U8g2@^2.35.0
   ```

2. Initialize 128x32 SSD1306 in Platform Layer:
   ```c
   U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2;
   
   void platform_display_init(void) {
       u8g2_Setup_ssd1306_i2c_128x32_univision_f(&u8g2, U8G2_R0, u8x8_byte_hw_i2c, u8x8_gpio_and_delay_stm32_hardware);
       u8g2_InitDisplay(&u8g2);
       u8g2_SetPowerSave(&u8g2, 0);
   }
   ```

3. Implement Platform Layer scaffold functions using u8g2
4. Add I2C pin configuration (PB8/PB9) and GPIO setup (PC0-PC4)
5. Add text truncation to 21 characters for 128x32 display
6. Implement graceful I2C degradation with LED fallback

**TDD Validation**:
```bash
# Test 4.8.3.1: PlatformIO build with u8g2
~/.platformio/penv/bin/pio run --environment weact_g431cb_hardware
# PASS: Firmware builds successfully with u8g2 library

# Test 4.8.3.2: Memory optimization
size .pio/build/weact_g431cb_hardware/firmware.elf | awk '/data/ {print $2}'
# Should show exactly 512 bytes for framebuffer overhead
# PASS: Optimal memory usage for 128x32

# Test 4.8.3.3: Hardware initialization test
# Upload firmware and check USART2 diagnostic output
# Should log: "OLED Init: 128x32 SSD1306 detected at 0x3C"
# PASS: u8g2 successfully communicates with OLED hardware

# Test 4.8.3.4: Text truncation
platform_display_text(0, 0, "This message is way too long for 128x32 display and should truncate cleanly");
# Should display: "This message is longe" (21 chars max)
# PASS: Long messages truncated to fit display width
```

**Validation Gate**: 128x32 OLED displays text via u8g2 scaffold with proper truncation

---

### **Chunk 4.8.4: Complete Graphics Pipeline Integration**
**Branch**: `chunk-4-8-4-graphics-pipeline`  
**Duration**: 2 days  
**Dependencies**: Chunk 4.8.3 complete

**Files to Modify**:
- `lib/vm_cockpit/src/execution_engine.cpp` (connect VM to Host Interface)
- `lib/vm_cockpit/src/host_interface.cpp` (connect to Platform)

**Implementation Tasks**:
1. Connect VM opcodes → Host Interface → Platform Layer u8g2
2. Complete ExecutionEngine switch cases for graphics opcodes
3. Test end-to-end: Bytecode → VM → Host → Platform → u8g2 → OLED
4. Validate concurrent operation: LED morse + button reading + display updates

**TDD Validation**:
```c
// Test 4.8.4.1: End-to-end graphics pipeline
// Create simple_display.c:
void setup() {
    display_clear();
    display_text(10, 8, "CockpitVM SOS");
    display_text(25, 24, "Ready");
    display_update();
}

// Compile and test:
lib/vm_compiler/tools/vm_compiler simple_display.c -o test.bin
# Load test.bin into VM and execute
# PASS: 128x32 OLED shows "CockpitVM SOS" and "Ready"

// Test 4.8.4.2: Concurrent operation
// Test LED morse + display updates simultaneously
display_text(0, 0, "Testing");
display_update();
led_morse_start("SOS");
while(led_morse_active()) {
    display_text(0, 16, "Morse Active");
    display_update();
}
// PASS: Display updates work while LED morse timing runs

// Test 4.8.4.3: Button integration
uint8_t buttons = button_read();
if(buttons & 0x01) {  // Button 1
    display_clear();
    display_text(20, 16, "Button 1");
    display_update();
}
// PASS: Button presses immediately update display
```

**Validation Gate**: Complete bytecode-to-OLED graphics pipeline functional with concurrent operations

---

### **Chunk 4.8.5: SOS Emergency Program Implementation**
**Branch**: `chunk-4-8-5-sos-emergency-program`  
**Duration**: 3 days  
**Dependencies**: Chunk 4.8.4 complete

**Files to Create**:
- `examples/sos_emergency.c`
- `lib/vm_compiler/validation/integration/test_sos_program.c`

**Implementation Tasks**:
1. Create complete SOS emergency program with 5-button interface
2. Implement display layouts optimized for 128x32:
   ```c
   // Line layouts for 128x32 (3 lines max):
   // Line 1 (y=8):  Status/mode messages  
   // Line 2 (y=16): Primary information
   // Line 3 (y=24): Instructions/prompts
   ```

3. Design interactive button functions:
   - Button 1 (PC0): Emergency SOS trigger
   - Button 2 (PC1): Display status information
   - Button 3 (PC2): Cycle display modes
   - Button 4 (PC3): Toggle morse speed
   - Button 5 (PC4): System reset/menu

4. Multi-modal coordination: Static OLED display + timer-driven LED morse

**TDD Validation**:
```c
// Test 4.8.5.1: Complete SOS program
void emergency_sos() {
    display_clear();
    display_text(32, 8, "SOS ACTIVE");     // Centered
    display_text(16, 16, "EMERGENCY");      // Status
    display_text(20, 24, "TRANSMITTING");  // Activity
    display_update();
    
    led_morse_start("... --- ...");        // LED only, no display timing
}

// Test button handling:
void handle_buttons() {
    uint8_t buttons = button_read();
    switch(buttons) {
        case 0x01: emergency_sos(); break;
        case 0x02: display_status(); break;
        case 0x04: display_menu(); break;
        case 0x08: toggle_morse_speed(); break;
        case 0x10: system_reset(); break;
    }
}
// PASS: All 5 buttons trigger appropriate responses

// Test 4.8.5.2: Program size validation
lib/vm_compiler/tools/vm_compiler sos_emergency.c -o sos.bin
ls -la sos.bin  # Must be < 2.5KB for SOS task allocation
# PASS: Complete program fits in memory allocation

// Test 4.8.5.3: LED morse timing accuracy
led_morse_start("SOS");
// Verify with oscilloscope: 200ms ±5ms dots, 600ms ±10ms dashes
# PASS: Accurate morse code timing for emergency signaling
```

**Validation Gate**: Complete interactive SOS program with all required functionality

---

### **Chunk 4.8.6: Oracle Small-Packet Integration**
**Branch**: `chunk-4-8-6-oracle-small-packets`  
**Duration**: 2 days  
**Dependencies**: Chunk 4.8.5 complete

**Files to Modify**:
- `tests/oracle_bootloader/lib/protocol_client.py`
- `tests/oracle_bootloader/oracle_cli.py`

**Implementation Tasks**:
1. Configure Oracle client for 64-byte DataPacket chunks
2. Implement reliable small-packet upload with per-packet CRC
3. Add fail-fast behavior on upload failures (no retry attempts)
4. Test resilience with larger SOS programs (>1KB)

**TDD Validation**:
```bash
# Test 4.8.6.1: Small packet upload
cd tests/oracle_bootloader && source oracle_venv/bin/activate
python oracle_cli.py --flash ../../examples/sos.bin --packet-size 64
# Should log: "Uploading 2.1KB in 34 packets (64 bytes each)"
# PASS: Large SOS program uploads via small reliable packets

# Test 4.8.6.2: Upload integrity
python oracle_cli.py --flash sos.bin --verify
# Should verify: "Program integrity: CRC16 match confirmed"  
# Each packet: "Packet 15/34: CRC16=0xA5B2 OK"
# PASS: End-to-end data integrity maintained

# Test 4.8.6.3: Fail-fast behavior test
# Simulate STM32G431CB overload during upload
# Oracle should fail immediately: "Upload failed: Device non-responsive"
# Should NOT retry automatically, require manual restart
# PASS: Fast failure prevents program corruption

# Test 4.8.6.4: Deployment workflow
python oracle_cli.py --flash sos.bin --execute
# Upload completes, program starts automatically
# Hardware should show: "SOS ACTIVE" on OLED, LED morse pattern
# PASS: Complete Oracle deployment workflow functional
```

**Validation Gate**: Reliable upload and execution of SOS programs via Oracle protocol

---

### **Chunk 4.8.7: Canopy GUI Integration**
**Branch**: `chunk-4-8-7-canopy-gui-integration`  
**Duration**: 3 days  
**Dependencies**: Chunk 4.8.6 complete

**Files to Modify**:
- `canopy_gui/src/components/DisplayPreview.tsx`
- `canopy_gui/src/templates/SOSEmergency.ts`
- `canopy_gui/src/services/OracleClient.ts`

**Implementation Tasks**:
1. Update Canopy display preview for 128x32 dimensions (vs original 128x48)
2. Create SOS emergency program template with 5-button interface
3. Integrate Oracle small-packet deployment as backend service
4. Add morse timing visualization for debugging patterns

**TDD Validation**:
```bash
# Test 4.8.7.1: Display preview accuracy  
cd canopy_gui && npm run dev
# Load SOS template, verify preview shows 128x32 mockup
# display_text(64, 16, "CENTER") should appear in exact center
# PASS: Preview matches 128x32 OLED dimensions exactly

# Test 4.8.7.2: SOS template functionality
# Navigate to "Templates → Emergency SOS"
# Should load complete working program with:
# - emergency_sos() function
# - handle_buttons() with 5-button interface  
# - LED morse patterns
# PASS: Template provides complete SOS program foundation

# Test 4.8.7.3: Deployment integration
# Edit SOS program in Canopy, click "Deploy to Hardware"
# Should call Oracle CLI with small-packet mode
# Progress indicator: "Uploading... 28/34 packets (82%)"
# Hardware verification: OLED shows program output
# PASS: End-to-end Canopy → Oracle → Hardware workflow

# Test 4.8.7.4: Morse visualization
# Canopy editor shows timing breakdown:
# "SOS Pattern: DOT(200ms) GAP(200ms) DOT(200ms) LETTER_GAP(600ms)"
# PASS: Timing visualization aids morse pattern development
```

**Validation Gate**: Complete development workflow from Canopy GUI to hardware execution

---

## **Success Criteria Summary**

### **Level 1: Foundation**
- ✅ VM graphics opcodes compile and generate correct bytecode
- ✅ Timer systems operate without conflicts or priority issues
- ✅ u8g2 library integrates with PlatformIO build system

### **Level 2: Integration**  
- ✅ 128x32 OLED displays bytecode-generated static text
- ✅ LED morse code runs with accurate non-blocking timing
- ✅ 5-button interface responds with proper debouncing

### **Level 3: Application**
- ✅ Complete SOS program demonstrates multi-modal emergency signaling
- ✅ Interactive button interface provides all required functions
- ✅ Program size fits within 2.5KB SOS task allocation

### **Level 4: Deployment**
- ✅ Oracle client reliably uploads programs via small-packet protocol
- ✅ Canopy GUI provides complete development workflow
- ✅ End-to-end: Canopy edit → Oracle deploy → Hardware execution

### **Level 5: Production Readiness**
- ✅ Graceful degradation when I2C communication fails
- ✅ System continues operation under timing pressure
- ✅ Memory usage stays within architectural constraints

---

## **Context Recreation Guide**

**Key Session Insights**:
1. **Simplified SOS approach**: OLED static text + LED morse timing (no display timing needed)
2. **128x32 hardware target**: Exact u8g2 match, 512-byte framebuffer optimization  
3. **Interrupt priority hierarchy**: Morse(1) > Button(2) > USART(3) > I2C(4) > VM(5)
4. **Scaffold strategy**: u8g2 temporary implementation, future native driver migration
5. **Small packet reliability**: 64-byte Oracle DataPackets with fail-fast policy

**Critical Technical Decisions**:
- Text truncation at 21 characters (deferred: word wrap, scrolling, bitmaps)
- Shared timer for 5-button debouncing (TIM7, 20ms windows)
- Graceful I2C degradation (FULL → ESSENTIAL → LED_ONLY → FAILED modes)
- Non-blocking LED morse state machine (TIM6 for timing precision)

**Implementation Approach**:
- Waterfall methodology with TDD validation gates
- Branch per chunk, merge after validation
- Clear dependency chain ensures solid foundations
- Pool questions framework achieved <2% ambiguity

This plan balances immediate MVP delivery with architectural integrity and provides clear migration paths for future optimization.