# ComponentVM Hardware Test Catalog
# Defines all available tests with metadata for workspace-isolated execution

tests:
  pc6_led_focused:
    source: test_pc6_led_focused.c
    dependencies: []  # Self-contained test
    description: "Focused PC6 LED test - confirmed working on WeAct STM32G431CB"
    timeout: 15s
    expected_patterns:
      - "PC6 LED test complete"
      - "workspace isolation working"
    hardware_requirements:
      - led_pc6
    category: hardware_validation
    stability: confirmed_working
    notes: "This test successfully validates our workspace isolation system"
    validation:
      execution_strategy: dual_pass
      required: false
      authority:
        overall: supplemental
        semihosting: optional
        memory: required
        timeout_strategy: fail_graceful
      timeout: 30s
      
      # Pass 1: Semihosting validation
      semihosting_checks:
        - contains: "PC6 LED test complete"
        - contains: "workspace isolation working"
        - not_contains: "ERROR"
      semihosting_timeout: 20s
      
      # Pass 2: Memory validation
      common_checks:
        - gpio_pc6_output
      memory_checks:
        gpioc_pc6_output_mode:
          address: 0x48000800        # GPIOC base
          offset: 0x00               # MODER register
          mask: 0x3000               # PC6 mode bits [13:12]
          expected: 0x1000           # Output mode (01)
          description: "PC6 configured as output mode"
      peripheral_checks:
        pc6:
          mode: output
          state: high
      
      # Rich diagnostics
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true
    
  # Additional tests to be migrated from legacy system
  led_basic:
    source: test_led_basic.c  # To be migrated
    dependencies: []
    description: "Basic LED toggle validation"
    timeout: 10s
    expected_patterns:
      - "LED test complete"
    hardware_requirements:
      - led_pc6
    category: hardware_validation
    stability: to_be_migrated
    
  uart_basic:
    source: test_uart_basic.c
    dependencies: []  # Self-contained test, no semihosting
    description: "UART communication validation - no semihosting, output via UART only"
    timeout: 45s
    expected_patterns:
      - "UART test complete"
      - "All UART functions validated"
    hardware_requirements:
      - usart2_pa2_pa3
      - led_pc6
    category: communication
    stability: development
    semihosting: false  # Disable semihosting for this test
    notes: "Test output via UART (PA2/PA3) - monitor with serial terminal at 115200 baud"
    
  uart_interrupt_echo:
    source: test_uart_interrupt_echo.c
    dependencies: []  # Self-contained test for interrupt validation
    description: "UART interrupt-driven echo test - validates circular buffer and UART RX interrupt"
    timeout: 60s
    expected_patterns:
      - "UART Interrupt Echo Test"
      - "Interrupt-driven UART RX with circular buffer"
      - "Echo active - start typing"
    hardware_requirements:
      - usart1_pa9_pa10
      - led_pc6
    category: communication
    stability: development
    semihosting: false  # No semihosting - UART I/O only
    notes: "Tests interrupt-driven UART RX. Connect to USART1 PA9/PA10 at 115200 baud and type characters to see echo"
    
  usart1_comprehensive:
    source: test_usart1_comprehensive.c
    dependencies: []  # Self-contained test with semihosting
    description: "Comprehensive USART1 test with Serial output and register validation"
    timeout: 60s
    expected_patterns:
      - "USART1 Test Complete"
      - "All USART1 functions validated successfully"
      - "Register states analyzed and documented"
    hardware_requirements:
      - usart2_pa2_pa3
      - led_pc6
    category: communication
    stability: development
    semihosting: true  # Enable semihosting for debug output
    notes: "Comprehensive USART2 validation with register analysis and optional interactive testing"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: required
        timeout_strategy: fail_graceful
      timeout: 45s
      
      # Pass 1: Semihosting validation
      semihosting_checks:
        - contains: "USART1 Comprehensive Test Starting"
        - contains: "USART1 initialized successfully"
        - contains: "USART1 comprehensive test execution complete"
        - contains: "CR1.UE: PASS"
        - contains: "CR1.TE: PASS"
        - contains: "ISR.TXE: PASS"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
        - sequence:
          - "Test 1: USART1 initialization"
          - "Test 2: Initial register validation"
          - "Test 3: Transmission pattern testing"
          - "Test 4: Post-transmission register validation"
          - "Test 5: Interactive reception testing"
          - "Test 6: Final register state validation"
      semihosting_timeout: 30s
      
      # Pass 2: Memory validation - USART2 register states
      memory_checks:
        usart2_enabled:
          address: 0x40004400        # USART2 base
          offset: 0x00               # CR1 register
          mask: 0x01                 # UE bit
          expected: 0x01             # USART enabled
          description: "USART2 enabled (CR1.UE)"
        usart2_transmitter_enabled:
          address: 0x40004400        # USART2 base
          offset: 0x00               # CR1 register
          mask: 0x08                 # TE bit
          expected: 0x08             # Transmitter enabled
          description: "USART2 transmitter enabled (CR1.TE)"
        usart2_receiver_enabled:
          address: 0x40004400        # USART2 base
          offset: 0x00               # CR1 register
          mask: 0x04                 # RE bit
          expected: 0x04             # Receiver enabled
          description: "USART2 receiver enabled (CR1.RE)"
        usart2_tx_empty:
          address: 0x40004400        # USART2 base
          offset: 0x1C               # ISR register
          mask: 0x80                 # TXE bit
          expected: 0x80             # TX empty
          description: "USART2 TX empty (ISR.TXE)"
        usart2_clock_enabled:
          address: 0x40021058        # RCC APB1ENR1
          offset: 0x00               # APB1ENR1 register
          mask: 0x20000              # USART2EN bit (bit 17)
          expected: 0x20000          # USART2 clock enabled
          description: "USART2 clock enabled (RCC.APB1ENR1.USART2EN)"
        usart2_baud_rate_configured:
          address: 0x40004400        # USART2 base
          offset: 0x0C               # BRR register
          mask: 0xFFFF               # Full BRR value
          expected: 0x015B           # 115200 baud at 40MHz effective (347 decimal, with DIV4 prescaler)
          description: "USART2 baud rate configured"
          
      # Cross-platform peripheral checks
      peripheral_checks:
        uart2:
          enabled: true
          baud_rate: 115200
          tx_ready: true
          
      # Rich diagnostics
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_both_passes: true

  # Bootloader foundation tests (Phase 4.5.2A validation)
  bootloader_foundation:
    source: bootloader/test_bootloader_foundation.c
    dependencies: 
      - common/bootloader_test_framework.h
    description: "Foundation validation for Phase 4.5.2A bootloader implementation"
    timeout: 15s
    expected_patterns:
      - "Bootloader Foundation Test"
      - "Test 1: Basic execution - PASS"
      - "Test 2: Memory operations - PASS" 
      - "Test 3: Stack operations - PASS"
      - "BOOTLOADER FOUNDATION TEST: PASS"
    hardware_requirements: []
    category: bootloader_foundation
    priority: high
    stability: phase_4_5_2a
    notes: "Essential validation for bootloader Phase 4.5.2A foundation"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 30s
      
      semihosting_checks:
        - contains: "=== Bootloader Foundation Test ==="
        - contains: "Test 1: Basic execution - PASS"
        - contains: "Test 2: Memory operations - PASS"
        - contains: "Test 3: Stack operations - PASS"
        - contains: "=== BOOTLOADER FOUNDATION TEST: PASS ==="
        - not_contains: "FAIL"
      semihosting_timeout: 20s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: false
        include_both_passes: true

  # Bootloader blocking foundation tests (Phase 4.5.1 validation)
  bootloader_blocking_foundation:
    source: test_bootloader_blocking_foundation.c
    dependencies: []
    description: "Blocking-first bootloader foundation validation - transport, state machine, timeout, resources"
    timeout: 30s
    expected_patterns:
      - "=== Bootloader Blocking Foundation Test Suite ==="
      - "✓ Blocking UART Init: PASS"
      - "✓ Timeout Overflow Protection: PASS"
      - "✓ State Machine Deterministic: PASS"
      - "✓ Resource Management: PASS"
      - "✓ Error Handling Recovery: PASS"
      - "✓ Bootloader Integration: PASS"
      - "=== Test Results: 6/6 passed ==="
      - "BOOTLOADER BLOCKING FOUNDATION: ALL TESTS PASSED"
    hardware_requirements:
      - usart1_pa9_pa10
      - led_pc6
    category: bootloader_foundation
    priority: high
    stability: phase_4_5_1
    notes: "Blocking-first bootloader foundation: transport, state machine, timeout management, resource cleanup"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 45s
      
      semihosting_checks:
        - contains: "=== Bootloader Blocking Foundation Test Suite ==="
        - contains: "Testing blocking UART initialization..."
        - contains: "PASS: Blocking UART initialization"
        - contains: "Testing timeout overflow protection..."
        - contains: "PASS: Timeout overflow protection"
        - contains: "Testing deterministic state machine..."
        - contains: "PASS: State machine deterministic transitions"
        - contains: "Testing resource management..."
        - contains: "PASS: Resource management"
        - contains: "Testing error handling and recovery..."
        - contains: "PASS: Error handling and recovery"
        - contains: "Testing bootloader integration..."
        - contains: "PASS: Bootloader integration"
        - contains: "=== Test Results: 6/6 passed ==="
        - contains: "BOOTLOADER BLOCKING FOUNDATION: ALL TESTS PASSED"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 35s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true

  # Protobuf Integration Test (Phase 4.5.2A validation)
  protobuf_integration:
    source: test_protobuf_integration.c
    dependencies: []
    description: "Phase 4.5.2A protobuf integration validation - nanopb encode/decode testing"
    timeout: 20s
    expected_patterns:
      - "=== Protobuf Integration Test Suite ==="
      - "✓ Protobuf Structure Compilation: PASS"
      - "✓ Protobuf Encoding: PASS"
      - "✓ Protobuf Decoding: PASS" 
      - "✓ Protobuf Memory Constraints: PASS"
      - "=== Test Results: 4/4 passed ==="
      - "PROTOBUF INTEGRATION: ALL TESTS PASSED"
    hardware_requirements:
      - basic_mcu
    category: protocol_integration
    priority: high
    stability: phase_4_5_2a
    notes: "Tests protobuf compilation, encoding/decoding, memory constraints with nanopb"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 30s
      
      semihosting_checks:
        - contains: "=== Protobuf Integration Test Suite ==="
        - contains: "Testing protobuf structure compilation..."
        - contains: "PASS: Protobuf structure compilation"
        - contains: "Testing protobuf encoding..."
        - contains: "PASS: Protobuf encoding"
        - contains: "Testing protobuf decoding..."
        - contains: "PASS: Protobuf decoding"
        - contains: "Testing protobuf memory constraints..."
        - contains: "PASS: Protobuf memory constraints"
        - contains: "=== Test Results: 4/4 passed ==="
        - contains: "PROTOBUF INTEGRATION: ALL TESTS PASSED"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 25s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: false
        include_both_passes: true

  # Binary Framing Integration Test (Phase 4.5.2B validation)
  binary_framing:
    source: test_binary_framing.c
    dependencies: []
    description: "Phase 4.5.2B binary framing validation - CRC16, parsing, encoding, flash staging"
    timeout: 30s
    expected_patterns:
      - "=== Binary Framing Integration Test Suite ==="
      - "✓ CRC16-CCITT Implementation: PASS"
      - "✓ Frame Encoding: PASS"
      - "✓ Frame Parsing: PASS" 
      - "✓ Flash Staging with 64-bit Alignment: PASS"
      - "✓ Error Injection: PASS"
      - "=== Test Results: 5/5 passed ==="
      - "BINARY FRAMING INTEGRATION: ALL TESTS PASSED"
    hardware_requirements:
      - basic_mcu
      - flash_memory
    category: protocol_integration
    priority: high
    stability: phase_4_5_2b
    notes: "Tests CRC16-CCITT, frame encoding/parsing, 64-bit flash alignment, error detection"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 45s
      
      semihosting_checks:
        - contains: "=== Binary Framing Integration Test Suite ==="
        - contains: "Testing CRC16-CCITT implementation..."
        - contains: "PASS: CRC16-CCITT implementation"
        - contains: "Testing frame encoding..."
        - contains: "PASS: Frame encoding"
        - contains: "Testing frame parsing..."
        - contains: "PASS: Frame parsing"
        - contains: "Testing flash staging with 64-bit alignment..."
        - contains: "PASS: Flash staging with 64-bit alignment"
        - contains: "Testing error injection - corrupted frame..."
        - contains: "PASS: Error injection"
        - contains: "=== Test Results: 5/5 passed ==="
        - contains: "BINARY FRAMING INTEGRATION: ALL TESTS PASSED"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 35s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: false
        include_both_passes: true

  # Flash Programming Protocol Test (Phase 4.5.2C validation)
  flash_programming_protocol:
    source: test_flash_programming_protocol.c
    dependencies: []
    description: "Phase 4.5.2C complete bootloader protocol validation - handshake through flash programming"
    timeout: 45s
    expected_patterns:
      - "=== Flash Programming Protocol Test Suite ==="
      - "✓ Handshake Protocol: PASS"
      - "✓ Flash Program Prepare: PASS"
      - "✓ Data Packet Processing: PASS" 
      - "✓ Flash Program Verify: PASS"
      - "✓ Complete Protocol Sequence: PASS"
      - "=== Test Results: 5/5 passed ==="
      - "FLASH PROGRAMMING PROTOCOL: ALL TESTS PASSED"
    hardware_requirements:
      - basic_mcu
      - flash_memory
    category: protocol_integration
    priority: high
    stability: phase_4_5_2c
    notes: "Complete bootloader protocol: handshake, prepare, data transfer, verification with ≤1024 byte transfers"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 60s
      
      semihosting_checks:
        - contains: "=== Flash Programming Protocol Test Suite ==="
        - contains: "Testing handshake protocol..."
        - contains: "PASS: Handshake protocol"
        - contains: "Testing flash program prepare phase..."
        - contains: "PASS: Flash program prepare phase"
        - contains: "Testing data packet processing..."
        - contains: "PASS: Data packet processing"
        - contains: "Testing flash program verify phase..."
        - contains: "PASS: Flash program verify phase"
        - contains: "Testing complete protocol sequence..."
        - contains: "PASS: Complete protocol sequence"
        - contains: "=== Test Results: 5/5 passed ==="
        - contains: "FLASH PROGRAMMING PROTOCOL: ALL TESTS PASSED"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 45s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: false
        include_both_passes: true

  # Flash Programming Protocol with Oracle Testing (Phase 4.5.2D validation)
  flash_programming_protocol_oracle:
    source: test_flash_programming_protocol_oracle.c
    dependencies: []
    description: "Phase 4.5.2C standard protocol test with Oracle reliability testing integration"
    timeout: 60s
    expected_patterns:
      - "=== Flash Programming Protocol Test with Oracle Integration ==="
      - "Step 1: Handshake"
      - "Handshake PASSED"
      - "Step 2: Prepare" 
      - "Prepare PASSED"
      - "Step 3: Data Transfer"
      - "Data Transfer PASSED"
      - "Step 4: Verify"
      - "Verify PASSED"
      - "=== STANDARD PROTOCOL TEST: PASSED ==="
      - "Oracle reliability tests will run automatically via workspace integration"
    hardware_requirements:
      - basic_mcu
      - flash_memory
      - usart1_pa9_pa10
    category: protocol_integration
    priority: high
    stability: phase_4_5_2d
    notes: "Standard protocol validation + Oracle error injection and recovery testing"
    oracle_scenarios:
      - normal
      - timeout_session
      - crc_frame_corruption
    oracle_sequences:
      - timeout_recovery_chain
      - crc_recovery_chain
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 75s
      
      semihosting_checks:
        - contains: "=== Flash Programming Protocol Test with Oracle Integration ==="
        - contains: "Step 1: Handshake"
        - contains: "Handshake PASSED"
        - contains: "Step 2: Prepare"
        - contains: "Prepare PASSED" 
        - contains: "Step 3: Data Transfer"
        - contains: "Data Transfer PASSED"
        - contains: "Step 4: Verify"
        - contains: "Verify PASSED"
        - contains: "=== STANDARD PROTOCOL TEST: PASSED ==="
        - contains: "Oracle reliability tests will run automatically via workspace integration"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 50s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: false
        include_both_passes: true

  # CockpitVM Bootloader Flash Programming Test (Phase 4.7.3 Golden Triangle Flash Validation)
  bootloader_flash_basic:
    source: test_bootloader_flash_basic.c
    dependencies: []
    description: "Phase 4.7.3 flash programming validation with Oracle CLI --flash command and memory verification"
    timeout: 90s
    semihosting: false  # Disable semihosting for UART communication with Oracle CLI --flash
    expected_patterns:
      - "=== CockpitVM Bootloader Flash Programming Test ==="
      - "Phase 4.7.3: Golden Triangle Flash Validation"
      - "Test Objective:"
      - "• Validate Oracle CLI --flash command with 0xDEADBEEF pattern"
      - "• Execute complete flash programming pipeline"
      - "• Verify dual-bank addressing and retry logic"
      - "✓ CockpitVM Flash Programming Bootloader initialized"
      - "✓ Flash-specific configuration applied"
      - "✓ Dual-bank addressing ready"
      - "=== ORACLE FLASH PROGRAMMING READY ==="
      - "Expected Oracle command:"
      - "Flash Target Configuration:"
      - "• Target: FLASH_TEST page (0x0801F800-0x0801FFFF)"
      - "=== ENTERING FLASH PROGRAMMING MODE ==="
      - "=== FLASH PROGRAMMING RESULTS ==="
      - "=== POST-FLASH MEMORY VALIDATION ==="
      - "=== COCKPITVM BOOTLOADER FLASH PROGRAMMING TEST: COMPLETE ==="
    hardware_requirements:
      - basic_mcu
      - flash_memory
      - usart1_pa9_pa10
      - led_pc6
    category: flash_programming
    priority: high
    stability: phase_4_7_3
    notes: "Oracle CLI --flash command integration test with 0xDEADBEEF pattern and post-flash memory verification"
    oracle_flash_command:
      command: "python oracle_cli.py --flash test_data/dummy_256_deadbeef.bin --device /dev/ttyUSB1"
      expected_data: "0xDEADBEEF pattern, 256 bytes"
      target_address: "0x0801F800"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: optional  # Semihosting validation optional - focus on memory validation
        memory: required       # Memory validation after Oracle --flash execution
        timeout_strategy: fail_graceful
      timeout: 120s
      
      semihosting_checks:
        - contains: "=== CockpitVM Bootloader Flash Programming Test ==="
        - contains: "Phase 4.7.3: Golden Triangle Flash Validation"
        - contains: "✓ CockpitVM Flash Programming Bootloader initialized"
        - contains: "✓ Flash-specific configuration applied"
        - contains: "✓ Dual-bank addressing ready"
        - contains: "=== ORACLE FLASH PROGRAMMING READY ==="
        - contains: "=== ENTERING FLASH PROGRAMMING MODE ==="
        - contains: "=== FLASH PROGRAMMING RESULTS ==="
        - contains: "=== POST-FLASH MEMORY VALIDATION ==="
        - contains: "=== COCKPITVM BOOTLOADER FLASH PROGRAMMING TEST: COMPLETE ==="
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 60s
      
      # Memory validation focuses on post-flash programming verification
      memory_checks:
        flash_test_page_programmed:
          address: 0x0801F800        # FLASH_TEST page start
          mask: 0xFFFFFFFF
          expected: 0xDEADBEEF       # First 32-bit word should be 0xDEADBEEF
          description: "Flash test page programmed with 0xDEADBEEF pattern"
        flash_test_page_not_erased:
          address: 0x0801F804        # Second word
          mask: 0xFFFFFFFF
          expected: 0xDEADBEEF       # Second 32-bit word should also be 0xDEADBEEF
          description: "Flash test page contains pattern (not erased)"
        flash_programming_integrity:
          address: 0x0801F810        # 16 bytes in
          mask: 0xFFFFFFFF
          expected: 0xDEADBEEF       # Pattern continues
          description: "Flash programming integrity throughout page"
        usart1_post_flash_state:
          address: 0x40013800        # USART1 base
          offset: 0x00               # CR1 register
          mask: 0x01                 # UE bit
          expected: 0x01             # USART enabled after Oracle --flash communication
          description: "USART1 enabled after Oracle --flash communication"
        flash_bootloader_cleanup:
          address: 0x20000000        # RAM start - check for clean bootloader state
          mask: 0xFFFFFFFF
          description: "Flash bootloader clean shutdown"
      
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_both_passes: true

  # CockpitVM Bootloader Oracle Basic Test (Focused Protocol Cycle Testing)
  bootloader_oracle_basic:
    source: test_bootloader_oracle_basic.c
    dependencies: []
    description: "Basic Oracle protocol cycle test - single handshake → prepare → transfer → verify cycle"
    timeout: 60s
    semihosting: false  # Disable semihosting for UART communication with Oracle
    expected_patterns:
      - "=== CockpitVM Bootloader Oracle Basic Test ==="
      - "Basic Oracle Protocol Cycle Testing"
      - "Test Objective:"
      - "Validate single complete Oracle protocol cycle via workspace integration"
      - "✓ CockpitVM Bootloader Framework initialized"
      - "✓ Oracle basic test configuration applied"
      - "=== ORACLE INTEGRATION READY ==="
      - "CockpitVM Bootloader Framework ready for Oracle testing"
      - "=== ENTERING ORACLE INTEGRATION MODE ==="
      - "CockpitVM Bootloader entering Oracle wait mode..."
      - "=== FRAMEWORK CLEANUP ==="
      - "✓ Framework cleanup complete"
      - "✓ Hardware state preserved for memory validation"
      - "=== COCKPITVM BOOTLOADER ORACLE BASIC TEST: COMPLETE ==="
    hardware_requirements:
      - basic_mcu
      - flash_memory
      - usart1_pa9_pa10
      - led_pc6
    category: oracle_basic
    priority: high
    stability: production_ready
    notes: "Focused Oracle basic test using existing workspace Oracle integration for single protocol cycle"
    oracle_scenarios:
      - normal  # Single normal protocol cycle via existing Oracle integration
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: optional  # Semihosting validation optional - focus on memory validation
        memory: required       # Memory validation after Oracle execution
        timeout_strategy: fail_graceful
      timeout: 90s
      
      semihosting_checks:
        - contains: "=== CockpitVM Bootloader Oracle Basic Test ==="
        - contains: "Basic Oracle Protocol Cycle Testing"
        - contains: "✓ CockpitVM Bootloader Framework initialized"
        - contains: "✓ Oracle basic test configuration applied"
        - contains: "=== ORACLE INTEGRATION READY ==="
        - contains: "=== ENTERING ORACLE INTEGRATION MODE ==="
        - contains: "CockpitVM Bootloader entering Oracle wait mode..."
        - contains: "=== FRAMEWORK CLEANUP ==="
        - contains: "✓ Framework cleanup complete"
        - contains: "✓ Hardware state preserved for memory validation"
        - contains: "=== COCKPITVM BOOTLOADER ORACLE BASIC TEST: COMPLETE ==="
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 45s
      
      # Memory validation focuses on post-Oracle hardware state
      memory_checks:
        bootloader_framework_cleanup:
          address: 0x20000000        # RAM start - check for clean framework state
          mask: 0xFFFFFFFF
          description: "CockpitVM Bootloader Framework clean shutdown"
        usart1_post_oracle_state:
          address: 0x40013800        # USART1 base
          offset: 0x00               # CR1 register
          mask: 0x01                 # UE bit
          expected: 0x01             # USART enabled after Oracle communication
          description: "USART1 enabled after Oracle communication"
        flash_target_post_oracle:
          address: 0x0801F800        # Flash page 63 - Oracle target
          mask: 0xFFFFFFFF
          description: "Flash page 63 state after Oracle programming"
        framework_statistics_accessible:
          address: 0x20000100        # Framework context area
          description: "Framework statistics accessible via memory"
      
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_both_passes: true


  # Bootloader Golden Triangle Integration Test (Phase 4.5.2E validation)
  bootloader_golden_triangle:
    source: test_bootloader_golden_triangle.c
    dependencies: []
    description: "Phase 4.5.2E complete golden triangle validation - embedded protocol + Oracle testing + integration"
    timeout: 120s
    semihosting: false  # Disable semihosting for UART communication with Oracle
    expected_patterns:
      - "=== ComponentVM Bootloader Golden Triangle Integration Test ==="
      - "Golden Triangle Components:"
      - "1. Embedded Protocol: Hardware bootloader with complete protocol stack"
      - "2. Oracle Testing: Error injection, scenario composition, recovery validation"
      - "3. Integration: Real hardware + real protocol + real error conditions"
      - "=== EMBEDDED PROTOCOL VALIDATION ==="
      - "Bootloader initialization: PASS"
      - "Protocol readiness: PASS"
      - "Standard protocol sequence: PASS"
      - "Error recovery capability: PASS"
      - "Hardware resource management: PASS"
      - "=== EMBEDDED PROTOCOL VALIDATION: COMPLETE ==="
      - "Golden Triangle Integration: READY FOR ORACLE TESTING"
      - "=== BOOTLOADER PROTOCOL LISTENING MODE ==="
      - "Bootloader entering 30-second listening window for Oracle testing..."
    hardware_requirements:
      - basic_mcu
      - flash_memory
      - usart1_pa9_pa10
      - led_pc6
    category: golden_triangle_integration
    priority: critical
    stability: phase_4_5_2e
    notes: "Complete end-to-end bootloader ecosystem validation with comprehensive Oracle integration"
    oracle_scenarios:
      - normal
      - timeout_session
      - timeout_handshake
      - crc_frame_corruption
    oracle_sequences:
      - timeout_recovery_chain
      - crc_recovery_chain
      - comprehensive_stress_test
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: skip  # Skip semihosting validation - UART test without semihosting
        memory: required   # Memory validation becomes primary validation method
        timeout_strategy: fail_graceful
      timeout: 150s
      
      semihosting_checks:
        - contains: "=== ComponentVM Bootloader Golden Triangle Integration Test ==="
        - contains: "Golden Triangle Components:"
        - contains: "1. Embedded Protocol: Hardware bootloader with complete protocol stack"
        - contains: "2. Oracle Testing: Error injection, scenario composition, recovery validation"
        - contains: "3. Integration: Real hardware + real protocol + real error conditions"
        - contains: "=== EMBEDDED PROTOCOL VALIDATION ==="
        - contains: "Step 1: Bootloader Initialization"
        - contains: "Bootloader initialization: PASS"
        - contains: "Step 2: Protocol Readiness Validation" 
        - contains: "Protocol readiness: PASS"
        - contains: "Step 3: Standard Protocol Sequence"
        - contains: "Standard protocol sequence: PASS"
        - contains: "Step 4: Error Recovery Capability"
        - contains: "Error recovery capability: PASS"
        - contains: "Step 5: Hardware Resource Management"
        - contains: "Hardware resource management: PASS"
        - contains: "=== EMBEDDED PROTOCOL VALIDATION: COMPLETE ==="
        - contains: "=== ORACLE INTEGRATION TRIGGER ==="
        - contains: "Embedded protocol validation successful"
        - contains: "Hardware bootloader ready for Oracle testing"
        - contains: "UART interface: USART1 PA9/PA10 at 115200 baud"
        - contains: "Protocol: Binary framing with protobuf messages"
        - contains: "Target: Flash page 63 (0x0801F800)"
        - contains: "Oracle scenarios will run automatically via workspace integration:"
        - contains: "Golden Triangle Integration: READY FOR ORACLE TESTING"
        - contains: "=== BOOTLOADER PROTOCOL LISTENING MODE ==="
        - contains: "Bootloader entering 30-second listening window for Oracle testing..."
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 90s
      
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_both_passes: true

  # ComponentVM Comprehensive Test Suite REMOVED - these were fake tests using native C arithmetic
  # Real ExecutionEngine validation tests created separately with actual VM bytecode execution

  # Minimal Memory Validation Test (Dual-Pass Validation Proof)
  memory_validation_minimal:
    source: test_memory_validation_minimal.c
    dependencies: []
    description: "Minimal dual-pass memory validation test using GPIOC MODER"
    timeout: 20s
    expected_patterns:
      - "Minimal Memory Validation Test (Dual-Pass)"
      - "PC6 configured as output"
      - "PC6 configuration: OUTPUT MODE - PASS"
      - "PC6 mask validation: PASS"
      - "Minimal Memory Validation Test: COMPLETE"
    hardware_requirements:
      - led_pc6
    category: memory_validation
    priority: high
    stability: development
    notes: "Proves dual-pass memory validation works - firmware validation + external validation"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: required
        timeout_strategy: fail_graceful
      timeout: 30s
      
      # Pass 1: Semihosting validation (firmware validation)
      semihosting_checks:
        - contains: "Minimal Memory Validation Test (Dual-Pass)"
        - contains: "PC6 configured as output"
        - contains: "PC6 configuration: OUTPUT MODE - PASS"
        - contains: "PC6 mask validation: PASS"
        - contains: "Minimal Memory Validation Test: COMPLETE"
        - not_contains: "FAIL"
        - sequence:
          - "Step 1: Configure PC6 as output"
          - "Step 2: Firmware validation (Pass 1)"
          - "Step 3: LED functionality test"
          - "Step 4: Ready for external validation (Pass 2)"
      semihosting_timeout: 25s
      
      # Pass 2: Memory validation (external validation via pyOCD)
      memory_checks:
        gpioc_pc6_output_mode:
          address: 0x48000800        # GPIOC MODER register
          mask: 0x3000               # PC6 mode bits [13:12]
          expected: 0x1000           # Output mode (01)
          description: "PC6 configured as output mode (GPIOC MODER)"
        gpioc_clock_enabled:
          address: 0x4002104C        # RCC AHB2ENR register
          mask: 0x04                 # GPIOC clock enable bit
          expected: 0x04             # GPIOC clock enabled
          description: "GPIOC clock enabled (RCC AHB2ENR)"
      
      # Rich diagnostics for debugging
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true

  # vm_comparison_comprehensive REMOVED - fake test using native C comparisons masquerading as VM test

  # vm_logical_comprehensive REMOVED - fake test using native C logical operations masquerading as VM test

  # vm_bitwise_comprehensive REMOVED - fake test using native C bitwise operations masquerading as VM test

  # REAL ExecutionEngine Phase 4.11.4 Validation Test
  execution_engine_arithmetic_gt:
    source: test_execution_engine_arithmetic_gt.c
    dependencies: []
    description: "REAL ExecutionEngine Phase 4.11.4 validation using actual VM bytecode execution"
    timeout: 45s
    expected_patterns:
      - "ExecutionEngine Phase 4.11.4 GT Validation"
      - "REAL VM BYTECODE EXECUTION TEST"
      - "Host flashing: 4 fast flashes (200ms intervals)"
      - "✓ Host LED sequence complete: 4 fast flashes validated"
      - "Testing Phase 4.11.4 direct handlers with REAL VM bytecode"
      - "✓ VM bytecode loaded successfully:"
      - "✓ SUCCESS: ExecutionEngine direct handlers executed VM bytecode"
      - "✓ Validated handlers: handle_push_direct, handle_sub_direct, handle_mul_direct"
      - "✓ Phase 4.11.4 cleanup successful - direct dispatch working!"
      - "Guest VM flashing: 8 long flashes (500ms intervals) via ExecutionEngine"
      - "✓ Guest VM LED sequence complete: 8 long flashes via ExecutionEngine"
      - "✓ ExecutionEngine GPIO handlers validated: handle_pin_mode_direct, handle_digital_write_direct"
      - "ExecutionEngine Phase 4.11.4 GT: SUCCESS!"
      - "FIRST REAL EXECUTIONENGINE VALIDATION COMPLETE!"
    hardware_requirements:
      - led_pc6
      - swd_debugger_pyocd
      - componentvm
      - execution_engine
    category: execution_engine_validation
    priority: critical
    stability: phase_4_11_4
    notes: "First genuine ExecutionEngine test using real VM bytecode execution through execute_single_instruction_direct() - validates Phase 4.11.4 dual dispatch elimination and static VMMemoryContext backing"
    platform_test_interface: true
    debugger_required: true
    real_vm_bytecode: true
    execution_engine_handlers_tested:
      - handle_halt_direct
      - handle_push_direct
      - handle_sub_direct
      - handle_mul_direct
      - handle_div_direct
      - handle_printf_direct
      - handle_pin_mode_direct
      - handle_digital_write_direct
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: required
        execution_engine: required
        timeout_strategy: fail_graceful
      timeout: 60s

      # Pass 1: Semihosting validation (VM execution results)
      semihosting_checks:
        - contains: "ExecutionEngine Phase 4.11.4 GT Validation"
        - contains: "REAL VM BYTECODE EXECUTION TEST"
        - contains: "Host flashing: 4 fast flashes (200ms intervals)"
        - contains: "✓ Host LED sequence complete: 4 fast flashes validated"
        - contains: "Testing Phase 4.11.4 direct handlers with REAL VM bytecode"
        - contains: "✓ VM bytecode loaded successfully:"
        - contains: "Executing VM bytecode through execute_single_instruction_direct()..."
        - contains: "✓ SUCCESS: ExecutionEngine direct handlers executed VM bytecode"
        - contains: "✓ Validated handlers: handle_push_direct, handle_sub_direct, handle_mul_direct"
        - contains: "✓ Validated handlers: handle_div_direct, handle_printf_direct, handle_pin_mode_direct"
        - contains: "✓ Phase 4.11.4 cleanup successful - direct dispatch working!"
        - contains: "Guest VM flashing: 8 long flashes (500ms intervals) via ExecutionEngine"
        - contains: "✓ Guest VM LED sequence complete: 8 long flashes via ExecutionEngine"
        - contains: "✓ ExecutionEngine GPIO handlers validated: handle_pin_mode_direct, handle_digital_write_direct"
        - contains: "ExecutionEngine Phase 4.11.4 GT: SUCCESS!"
        - contains: "✓ Static VMMemoryContext backing working"
        - contains: "✓ Direct dispatch eliminates dual dispatch complexity"
        - contains: "FIRST REAL EXECUTIONENGINE VALIDATION COMPLETE!"
        - not_contains: "CRITICAL FAILURE"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 45s

      # Pass 2: Memory validation (ExecutionEngine state and GPIO transitions)
      memory_checks:
        gpioc_pc6_configured_by_vm:
          address: 0x48000800        # GPIOC base
          offset: 0x00               # MODER register
          mask: 0x3000               # PC6 mode bits [13:12]
          expected: 0x1000           # Output mode (01) - set by ExecutionEngine handle_pin_mode_direct
          description: "PC6 configured as output by ExecutionEngine VM bytecode execution"
        gpioc_pc6_pin_state_final:
          address: 0x48000800        # GPIOC base
          offset: 0x14               # ODR register
          mask: 0x40                 # PC6 output bit [6]
          expected: 0x00             # LOW (final state after VM execution: HIGH then LOW)
          description: "PC6 final output state LOW after VM DIGITAL_WRITE sequence"
        gpioc_clock_enabled_for_vm:
          address: 0x4002104C        # RCC AHB2ENR
          mask: 0x04                 # GPIOC clock enable bit [2]
          expected: 0x04             # GPIOC clock enabled
          description: "GPIOC clock enabled for VM GPIO operations"
        execution_engine_stack_state:
          address: 0x20000000        # RAM start - ExecutionEngine stack area
          description: "ExecutionEngine stack state after VM execution"
        component_vm_memory_context:
          address: 0x20001000        # VMMemoryContext area
          description: "Static VMMemoryContext backing store used by ExecutionEngine"

      # Rich diagnostics
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_execution_engine_metrics: true
        include_vm_bytecode_analysis: true
        include_both_passes: true

  # I2C Peripheral Validation Test (Phase 4.8.1)
  test_i2c_peripheral_validation:
    source: test_i2c_peripheral_validation.c
    dependencies: []
    description: "Phase 4.8.1 I2C peripheral validation - device detection, command/data transmission, reliability testing"
    timeout: 30s
    expected_patterns:
      - "I2C Peripheral Validation Test Starting"
      - "Test 1: Device Detection"
      - "Test 2: Command Transmission" 
      - "Test 3: Data Transmission"
      - "Test 4: Reliability Testing"
      - "I2C Peripheral Validation: COMPLETE"
    hardware_requirements:
      - i2c1_pc11_pa8
      - ssd1306_oled_128x32
    category: peripheral_validation
    priority: high
    stability: phase_4_8_1
    notes: "Hardware validation for 128x32 SSD1306 OLED via I2C3: PA8=SCL, PC11=SDA @ 100kHz"
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 45s
      
      semihosting_checks:
        - contains: "I2C Peripheral Validation Test Starting"
        - contains: "Test 1: Device Detection"
        - contains: "Device detected at address 0x3C: PASS"
        - contains: "Test 2: Command Transmission"
        - contains: "Display command sequence: PASS"
        - contains: "Test 3: Data Transmission"
        - contains: "Data pattern transmission: PASS"
        - contains: "Test 4: Reliability Testing"
        - contains: "Reliability: PASS"
        - contains: "I2C Peripheral Validation: COMPLETE"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 30s
      
      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true

  # I2C Continuous Scan Test (Phase 4.8.1 Oscilloscope Analysis)
  test_i2c_scan_continuous:
    source: test_i2c_scan_continuous.c
    dependencies: []
    description: "Continuous I2C scan with LED indicators and GT DIAG framework integration"
    timeout: 60s
    semihosting: false  # Disable semihosting - uses GT DIAG framework
    diag_enabled: true  # Enable Golden Triangle DIAG framework
    expected_patterns:
      - "Golden Triangle Diagnostics v4.8"
      - "CockpitVM I2C Continuous Scan Test"
      - "Phase 4.8.1: Oscilloscope Analysis"
      - "I2C3 peripheral ready"
      - "Starting continuous I2C scan"
      - "OSCILLOSCOPE SETUP INSTRUCTIONS"
    hardware_requirements:
      - i2c1_pc11_pa8
      - ssd1306_oled_128x32
      - led_pc6
      - usart2_pa2_pa3
    category: peripheral_validation
    priority: high
    stability: phase_4_8_1
    notes: "Continuous I2C scanning with PC6 LED startup sequence (3 blinks), GT DIAG framework via USART2 @ PA2/PA3, oscilloscope analysis @ 100kHz, 500ms intervals"
    validation:
      execution_strategy: diag_only
      required: false
      authority:
        overall: supplemental
        semihosting: skip
        memory: optional
        timeout_strategy: manual_stop
      timeout: 120s

      diagnostics:
        verbosity: minimal
        memory_dump_range: 0x10
        include_peripheral_summary: false
        include_both_passes: false

  # STM32G4 Debug Detection Test (Phase 4.9.0)
  stm32g4_debug_detection_gt:
    source: test_stm32g4_debug_detection_gt.c
    dependencies: []
    description: "Phase 4.9.0 STM32G4 hardware debugger detection validation using CoreDebug DHCSR register"
    timeout: 20s
    expected_patterns:
      - "STM32G4 Debug Detection Test Starting"
      - "CoreDebug DHCSR register access test"
      - "Debugger detection with pyOCD connected"
      - "DHCSR register value: 0x"
      - "C_DEBUGEN bit detected: PASS"
      - "stm32g4_debug_is_debugger_connected() returns: true"
      - "STM32G4 Debug Detection Test Complete"
    hardware_requirements:
      - swd_debugger_pyocd
      - stm32g4_coredebug
    category: debug_hardware_validation
    priority: high
    stability: phase_4_9_0
    notes: "Hardware debugger detection validation for printf routing - REQUIRES active pyOCD session via SWD"
    platform_test_interface: true
    debugger_required: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: required
        timeout_strategy: fail_graceful
      timeout: 30s

      # Pass 1: Semihosting validation
      semihosting_checks:
        - contains: "STM32G4 Debug Detection Test Starting"
        - contains: "CoreDebug DHCSR register accessible: PASS"
        - contains: "Debugger detection result: PASS"
        - contains: "C_DEBUGEN bit detected: PASS"
        - contains: "API consistency check: PASS"
        - not_contains: "FAIL"
      semihosting_timeout: 25s

      # Pass 2: Memory validation
      memory_checks:
        coredebug_dhcsr_access:
          address: 0xE000EDF0        # ARM CoreDebug DHCSR register
          mask: 0x00000001           # C_DEBUGEN bit mask
          expected: 0x00000001       # C_DEBUGEN bit set when debugger connected
          description: "CoreDebug DHCSR C_DEBUGEN bit indicates debugger connected"

      # Rich diagnostics
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x10
        include_peripheral_summary: true
        include_both_passes: true

  # IOController Printf Routing Test (Phase 4.9.1)
  iocontroller_printf_routing_gt:
    source: test_iocontroller_printf_routing_gt.c
    dependencies: []
    description: "Phase 4.9.1 IOController printf routing with CoreDebug detection validation"
    timeout: 25s
    expected_patterns:
      - "IOController Printf Routing Test Starting"
      - "CoreDebug detection: CONNECTED"
      - "Printf routing mechanism validation"
      - "ROUTING_TEST: Hello from guest printf"
      - "ROUTING_TEST: Debugger connected, routing to semihosting"
      - "Routing consistency: PASS"
      - "Multiple routing calls: PASS"
      - "IOController Printf Routing Test Complete"
    hardware_requirements:
      - swd_debugger_pyocd
      - stm32g4_coredebug
      - iocontroller_printf
    category: printf_routing_validation
    priority: high
    stability: phase_4_9_1
    notes: "Printf routing validation for CockpitVM guest applications - REQUIRES active pyOCD session via SWD"
    platform_test_interface: true
    debugger_required: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 35s

      # Pass 1: Semihosting validation
      semihosting_checks:
        - contains: "IOController Printf Routing Test Starting"
        - contains: "CoreDebug detection: CONNECTED"
        - contains: "Printf routing mechanism: PASS"
        - contains: "ROUTING_TEST: Hello from guest printf"
        - contains: "Routing consistency: PASS"
        - not_contains: "FAIL"
      semihosting_timeout: 30s

      # Pass 2: Printf routing validation
      routing_checks:
        printf_routing_validation:
          mechanism: "coredebug_detection"
          expected_target: "semihosting"
          description: "Printf routing via CoreDebug detection to semihosting"

      # Rich diagnostics
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x10
        include_peripheral_summary: true
        include_both_passes: true

  # Guest Printf Integration Test (Phase 4.9.1)
  guest_printf_integration:
    source: test_guest_printf_integration.c
    dependencies: []
    description: "Phase 4.9.1 Guest application printf integration end-to-end validation through IOController"
    timeout: 30s
    expected_patterns:
      - "Guest Printf Integration Test Starting"
      - "IOController initialization: PASS"
      - "String registration: PASS"
      - "CoreDebug detection: CONNECTED"
      - "Guest printf integration: PASS"
      - "Multiple guest printf calls: PASS"
      - "Routing consistency: PASS"
      - "Guest Printf Integration Test Complete"
    hardware_requirements:
      - swd_debugger_pyocd
      - stm32g4_coredebug
      - iocontroller_printf
    category: printf_routing_validation
    priority: high
    stability: phase_4_9_1
    notes: "End-to-end guest application printf validation through complete CockpitVM stack - REQUIRES active pyOCD session via SWD"
    platform_test_interface: true
    debugger_required: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 35s

      # Pass 1: Semihosting validation
      semihosting_checks:
        - contains: "Guest Printf Integration Test Starting"
        - contains: "IOController initialization: PASS"
        - contains: "String registration: PASS"
        - contains: "Guest printf integration: PASS"
        - contains: "Routing consistency: PASS"
        - not_contains: "FAIL"
      semihosting_timeout: 30s

      # Pass 2: Guest printf validation
      guest_printf_checks:
        iocontroller_integration:
          mechanism: "vm_printf_through_iocontroller"
          expected_target: "semihosting"
          description: "Guest printf routed through IOController to semihosting"

      # Rich diagnostics
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x10
        include_peripheral_summary: true
        include_both_passes: true

  # GPIO Pin 13 Golden Triangle Test (Phase 4.9.1.A)
  gpio_pin13_golden_triangle:
    source: test_gpio_pin13_golden_triangle.c
    dependencies: []
    description: "Phase 4.9.1.A GPIO Pin 13 (PC6) Golden Triangle validation with Platform Test Interface"
    timeout: 30s
    expected_patterns:
      - "GPIO Pin 13 Golden Triangle Test Starting"
      - "Test 1: Configuring Pin 13 as OUTPUT"
      - "Test 2: Setting Pin 13 HIGH"
      - "Test 3: Setting Pin 13 LOW"
      - "GPIO_VALIDATION_START"
      - "Expected MODER bits for Pin 13: 01 (output mode)"
      - "Expected ODR state transitions: 0→1→0"
      - "GPIO_VALIDATION_END"
      - "GPIO Pin 13 Golden Triangle Test Complete"
    hardware_requirements:
      - led_pc6
      - gpio_pin13_pc6
    category: gpio_hardware_validation
    priority: high
    stability: phase_4_9_1_a
    notes: "GPIO Pin 13 (PC6) Golden Triangle validation: ArduinoC compilation → VM execution → Platform Test Interface hardware validation"
    platform_test_interface: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: required
        timeout_strategy: fail_graceful
      timeout: 45s

      # Pass 1: Semihosting validation (Golden Triangle Requirement 2)
      semihosting_checks:
        - contains: "GPIO Pin 13 Golden Triangle Test Starting"
        - contains: "Test 1: Configuring Pin 13 as OUTPUT"
        - contains: "Test 2: Setting Pin 13 HIGH"
        - contains: "Test 3: Setting Pin 13 LOW"
        - contains: "GPIO_VALIDATION_START"
        - contains: "Expected MODER bits for Pin 13: 01 (output mode)"
        - contains: "Expected ODR state transitions: 0→1→0"
        - contains: "Expected register access: GPIOC base 0x48000800"
        - contains: "GPIO_VALIDATION_END"
        - contains: "GPIO Pin 13 Golden Triangle Test Complete"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 25s

      # Pass 2: Platform Test Interface validation (Golden Triangle Requirement 3)
      memory_checks:
        gpioc_pin13_output_mode:
          address: 0x48000800        # GPIOC base
          offset: 0x00               # MODER register
          mask: 0x3000               # Pin 6 mode bits [13:12]
          expected: 0x1000           # Output mode (01)
          description: "GPIO Pin 13 (PC6) configured as output mode"
        gpioc_pin13_odr_control:
          address: 0x48000800        # GPIOC base
          offset: 0x14               # ODR register
          mask: 0x40                 # Pin 6 output bit [6]
          description: "GPIO Pin 13 (PC6) output data register access"
        gpioc_clock_enabled:
          address: 0x4002104C        # RCC AHB2ENR
          mask: 0x04                 # GPIOC clock enable bit [2]
          expected: 0x04             # GPIOC clock enabled
          description: "GPIOC clock enabled for Pin 13 operations"

      # Platform Test Interface checks
      platform_interface_checks:
        pin13_output_mode_validation:
          function: "pin13_is_output_mode"
          expected_return: true
          description: "Platform Test Interface confirms Pin 13 is in output mode"
        pin13_register_access_validation:
          function: "gpioc_get_moder_register"
          expected_mask: "0x48000800"
          description: "Platform Test Interface can access GPIOC registers"
        pin13_atomic_validation:
          function: "pin13_set_and_verify_output"
          test_sequence: ["high", "low"]
          description: "Platform Test Interface atomic set-and-verify operations"

      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x40
        include_peripheral_summary: true
        include_both_passes: true
        platform_test_interface: true

  # GPIO Platform Interface Integration Test (Phase 4.9.1.A)
  gpio_platform_interface_integration:
    source: test_gpio_platform_interface_integration.c
    dependencies: []
    description: "Phase 4.9.1.A GPIO Platform Interface integration test"
    timeout: 30s
    expected_patterns:
      - "GPIO Platform Interface Integration Test"
      - "Integration Test 1: GPIO Configuration"
      - "Integration Test 2: GPIO Write Operations"
      - "Integration Test 3: GPIO Read Operations"
      - "INTEGRATION_TEST_START"
      - "Expected GPIO commands: configure, write_high, write_low, read"
      - "INTEGRATION_TEST_END"
      - "GPIO Platform Interface Integration Test Complete"
    hardware_requirements:
      - led_pc6
      - gpio_pin13_pc6
    category: gpio_hardware_validation
    priority: medium
    stability: phase_4_9_1_a
    notes: "GPIO Platform Interface integration validation for Phase 4.9.1.A"
    platform_test_interface: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: supplemental
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 45s

      semihosting_checks:
        - contains: "GPIO Platform Interface Integration Test"
        - contains: "Integration Test 1: GPIO Configuration"
        - contains: "Integration Test 2: GPIO Write Operations"
        - contains: "Integration Test 3: GPIO Read Operations"
        - contains: "INTEGRATION_TEST_START"
        - contains: "INTEGRATION_TEST_END"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 25s

      diagnostics:
        verbosity: standard
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true

  # GPIO Pin 13 Bytecode Test (Phase 4.9.2)
  gpio_pin13_bytecode_phase_4_9_2:
    source: gpio_pin13_bytecode_phase_4_9_2.c
    dependencies: []
    description: "Phase 4.9.2 GPIO Pin 13 bytecode validation via CockpitVM execution"
    timeout: 30s
    expected_patterns:
      - "GPIO_BYTECODE_TEST_START"
      - "GPIO_PIN_13_CONFIGURED_OUTPUT"
      - "GPIO_PIN_13_WRITE_HIGH"
      - "GPIO_PIN_13_WRITE_LOW"
      - "GPIO_BYTECODE_TEST_COMPLETE"
    hardware_requirements:
      - gpio_pin13
      - swd_debugger_pyocd
      - stm32g4_coredebug
    category: gpio_hardware_validation
    priority: high
    stability: phase_4_9_2
    notes: "Generated bytecode test: 22 instructions, 5 strings - Tests ArduinoC → bytecode → CockpitVM execution"
    platform_test_interface: true
    debugger_required: true
    bytecode_test: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 35s

      semihosting_checks:
        - contains: "GPIO_BYTECODE_TEST_START"
        - contains: "GPIO_PIN_13_CONFIGURED_OUTPUT"
        - contains: "GPIO_PIN_13_WRITE_HIGH"
        - contains: "GPIO_PIN_13_WRITE_LOW"
        - contains: "GPIO_BYTECODE_TEST_COMPLETE"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 30s

      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x10
        include_peripheral_summary: true
        include_both_passes: true

  # Printf Routing Bytecode Test (Phase 4.9.2)
  printf_routing_bytecode_phase_4_9_2:
    source: printf_routing_bytecode_phase_4_9_2.c
    dependencies: []
    description: "Phase 4.9.2 printf routing bytecode validation via CockpitVM IOController"
    timeout: 30s
    expected_patterns:
      - "PRINTF_ROUTING_BYTECODE_START"
      - "Testing IOController printf routing"
      - "Phase 4.9.2 printf routing via CockpitVM bytecode!"
      - "CoreDebug detection should route this to semihosting"
      - "PRINTF_ROUTING_BYTECODE_COMPLETE"
    hardware_requirements:
      - swd_debugger_pyocd
      - stm32g4_coredebug
      - iocontroller_printf
    category: printf_routing_validation
    priority: high
    stability: phase_4_9_2
    notes: "Generated bytecode test: 13 instructions, 5 strings - Tests printf routing via IOController debugger detection"
    platform_test_interface: true
    debugger_required: true
    bytecode_test: true
    validation:
      execution_strategy: dual_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 35s

      semihosting_checks:
        - contains: "PRINTF_ROUTING_BYTECODE_START"
        - contains: "Testing IOController printf routing"
        - contains: "Phase 4.9.2 printf routing via CockpitVM bytecode!"
        - contains: "CoreDebug detection should route this to semihosting"
        - contains: "PRINTF_ROUTING_BYTECODE_COMPLETE"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 30s

      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x10
        include_peripheral_summary: true
        include_both_passes: true

  # Phase 4.9.3 ComponentVM Auto-Execution Test
  vm_auto_execution_golden_triangle:
    source: test_vm_auto_execution_golden_triangle.c
    dependencies: []
    description: "Phase 4.9.3 ComponentVM auto-execution validation via Golden Triangle"
    timeout: 45s
    expected_patterns:
      - "VM_AUTO_EXECUTION_TEST_START"
      - "Testing ComponentVM auto-execution integration"
      - "Program available check:"
      - "Testing result string function"
      - "Success string: Success"
      - "No program string: No program found"
      - "Attempting auto-execution test run"
      - "Auto-execution result:"
      - "ComponentVM auto-execution framework validated"
      - "Integration glue working correctly"
      - "VM_AUTO_EXECUTION_TEST_COMPLETE"
    hardware_requirements:
      - gpio_pin13
      - vm_auto_execution
      - componentvm
    category: vm_auto_execution_validation
    priority: high
    stability: phase_4_9_3
    notes: "Validates elegant ComponentVM auto-execution solution - 100 lines total implementation"
    platform_test_interface: true
    debugger_required: true
    bytecode_info:
      compilation_method: "phase_4_9_3_minimal_auto_execution"
      auto_execution: true
    validation:
      execution_strategy: vm_auto_execution
      required: true
      authority:
        overall: authoritative
        semihosting: required
        vm_auto_execution: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 40s
      semihosting_checks:
        - contains: "VM_AUTO_EXECUTION_TEST_START"
        - contains: "Testing ComponentVM auto-execution integration"
        - contains: "Program available check:"
        - contains: "Testing result string function"
        - contains: "Success string: Success"
        - contains: "No program string: No program found"
        - contains: "Attempting auto-execution test run"
        - contains: "Auto-execution result:"
        - contains: "ComponentVM auto-execution framework validated"
        - contains: "Integration glue working correctly"
        - contains: "VM_AUTO_EXECUTION_TEST_COMPLETE"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 35s
      vm_auto_execution_checks:
        - contains: "Phase 4.9.3: Starting ComponentVM auto-execution"
        - contains: "Valid guest program found"
        - contains: "Guest program loaded into ComponentVM"
        - contains: "Guest program execution complete"
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_vm_metrics: true
        include_both_passes: true

  # Phase 4.9.4 Host Startup Coordination Test
  phase_4_9_4_host_startup_coordination:
    source: test_phase_4_9_4_host_startup_coordination.c
    dependencies: []
    description: "Phase 4.9.4 unified host startup coordination validation"
    timeout: 30s
    expected_patterns:
      - "Phase 4.9.4: Host Startup Coordination Test"
      - "System initialization result: SUCCESS"
      - "PC13 button state: NOT_PRESSED"
      - "Auto-execution result: No program found"
      - "GT_VALIDATION: Startup coordination framework operational"
      - "GT_VALIDATION: PC13 button detection working"
      - "GT_VALIDATION: Auto-execution integration functional"
      - "GT_VALIDATION: vm_bootloader fallback path available"
      - "Phase 4.9.4: Host Startup Coordination Test COMPLETE"
    hardware_requirements:
      - gpio_pc13
      - led_pc6
      - vm_host_startup
      - vm_auto_execution
    category: host_startup_integration
    priority: high
    stability: phase_4_9_4
    notes: "Tests unified startup coordinator with button detection, auto-execution integration, and bootloader fallback"
    validation:
      execution_strategy: single_pass
      required: true
      authority:
        overall: authoritative
        semihosting: required
      timeout: 30s
      semihosting_checks:
        - contains: "Phase 4.9.4: Host Startup Coordination Test"
        - contains: "System initialization result: SUCCESS"
        - contains: "PC13 button state: NOT_PRESSED"
        - contains: "Auto-execution result: No program found"
        - contains: "GT_VALIDATION: Startup coordination framework operational"
        - contains: "GT_VALIDATION: PC13 button detection working"
        - contains: "GT_VALIDATION: Auto-execution integration functional"
        - contains: "GT_VALIDATION: vm_bootloader fallback path available"
        - contains: "GT_VALIDATION: Result handling and error reporting working"
        - contains: "GPIO configuration successful"
        - contains: "Phase 4.9.4: Host Startup Coordination Test COMPLETE"
        - not_contains: "FAILED"
        - not_contains: "ERROR"
      semihosting_timeout: 25s
      memory_checks:
        gpio_pc13_input_config:
          address: 0x48000800  # GPIOC MODER register
          mask: 0x0C000000     # PC13 mode bits [27:26]
          expected: 0x00000000 # Input mode (00)
          description: "PC13 configured as input for button detection"
        gpio_pc6_output_config:
          address: 0x48000800  # GPIOC MODER register
          mask: 0x00003000     # PC6 mode bits [13:12]
          expected: 0x00001000 # Output mode (01)
          description: "PC6 configured as output for LED"
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_both_passes: true

  # Phase 4.9.4: Complete Auto-Execution with Oracle Integration
  phase_4_9_4_auto_execution_complete:
    source: test_phase_4_9_4_auto_execution_complete.c
    dependencies: []
    description: "Phase 4.9.4 complete auto-execution validation with Oracle integration - flash ArduinoC bytecode and test startup coordination"
    timeout: 120s
    semihosting: true  # Enable semihosting to capture guest program output after Oracle disconnects
    oracle_scenarios:
      - "flash_phase_4_9_4_bytecode"  # Custom Oracle scenario to flash our ArduinoC bytecode
    expected_patterns:
      - "=== COCKPITVM PHASE 4.9.4 AUTO-EXECUTION COMPLETE TEST ==="
      - "Oracle Integration + Startup Coordination + Guest Execution"
      - "✓ CockpitVM Bootloader initialized for Oracle"
      - "=== ORACLE INTEGRATION READY ==="
      - "Oracle Result: BYTECODE FLASHED SUCCESSFULLY ✓"
      - "✓ Host startup systems initialized"
      - "PC13 button: NOT_PRESSED (continue to auto-execution)"
      - "✓ Guest program detected at Page 63"
      - "✓ Guest program execution initiated"
      - "✓ SUCCESS: Guest program LED activity detected"
      - "✓ COMPLETE SUCCESS: End-to-end auto-execution validated"
      - "PHASE_4_9_4_COMPLETE_SUCCESS"
    hardware_requirements:
      - usart1_pa9_pa10  # Oracle communication
      - usart2_pa2_pa3   # Diagnostic output
      - gpio_pc13        # Button input
      - led_pc6          # Guest program GPIO validation
    category: integration
    priority: high
    stability: phase_4_9_4
    notes: "Complete end-to-end validation: Oracle → Flash → Startup → Auto-exec → Guest → GPIO. Requires Oracle integration with custom bytecode."

  # Phase 4.9.4: Debug Minimal - Isolate hang point after Oracle
  phase_4_9_4_debug_minimal:
    source: test_phase_4_9_4_debug_minimal.c
    dependencies: []
    description: "Minimal debug test to isolate hang point after Oracle flash completion"
    timeout: 60s
    semihosting: false  # Disable semihosting for Oracle UART communication
    oracle_scenarios:
      - "flash_phase_4_9_4_bytecode"  # Same Oracle scenario as full test
    expected_patterns:
      - "=== MINIMAL DEBUG TEST ==="
      - "✓ Diagnostics initialized"
      - "✓ Bootloader initialized"
      - "DEBUG_ORACLE_COMPLETED"
      - "=== POST-ORACLE DEBUG CHECKPOINT 1 ==="
      - "DEBUG_CHECKPOINT_1"
      - "=== POST-ORACLE DEBUG CHECKPOINT 2 ==="
      - "DEBUG_CHECKPOINT_2"
      - "=== POST-ORACLE DEBUG CHECKPOINT 3 ==="
      - "DEBUG_CHECKPOINT_3"
      - "=== DEBUG TEST COMPLETE ==="
      - "DEBUG_TEST_FINISHED"
    hardware_requirements:
      - usart1_pa9_pa10  # Oracle communication
      - usart2_pa2_pa3   # Diagnostic output
      - gpio_pc13        # LED for basic testing
    category: debug
    priority: high
    stability: debug
    notes: "Minimal test to isolate exact hang point after Oracle completion. Should reach all debug checkpoints if system is working correctly."

# Test suites for batch execution
test_suites:
  smoke_tests:
    description: "Quick validation tests for CI/CD"
    tests:
      - pc6_led_focused
    timeout: 30s
    
  hardware_validation:
    description: "Complete hardware validation suite"
    tests:
      - pc6_led_focused
      - led_basic
      - gpio_pin13_golden_triangle
    timeout: 90s
    
  bootloader_foundation:
    description: "Bootloader Phase 4.5.1 blocking foundation tests"
    tests:
      - bootloader_blocking_foundation
    timeout: 60s
    
  bootloader_phase_4_5_2a:
    description: "Bootloader Phase 4.5.2A foundation tests"
    tests:
      - bootloader_foundation
    timeout: 30s
  
  bootloader_phase_4_5_2_complete:
    description: "Complete bootloader Phase 4.5.2 validation suite"
    tests:
      - bootloader_blocking_foundation
      - protobuf_integration
      - binary_framing
      - flash_programming_protocol
      - flash_programming_protocol_oracle
      - bootloader_golden_triangle
    timeout: 600s
  
  oracle_basic:
    description: "Basic CockpitVM Bootloader Oracle protocol cycle testing"
    tests:
      - bootloader_oracle_basic
    timeout: 90s
    
  oracle_validation:
    description: "CockpitVM Bootloader Oracle validation testing"
    tests:
      - bootloader_oracle_basic
    timeout: 120s
  
  flash_programming:
    description: "Phase 4.7.3 Flash Programming validation with Oracle CLI --flash"
    tests:
      - bootloader_flash_basic
    timeout: 120s
    
  golden_triangle_integration:
    description: "Golden triangle integration tests"
    tests:
      - bootloader_golden_triangle
    timeout: 180s
    
  # vm_comprehensive test suite REMOVED - contained fake tests using native C operations instead of ExecutionEngine

  execution_engine_validation:
    description: "REAL ExecutionEngine Phase 4.11.4 validation using actual VM bytecode execution"
    tests:
      - execution_engine_arithmetic_gt
    timeout: 75s
    notes: "First genuine ExecutionEngine validation with real VM bytecode through execute_single_instruction_direct() - replaces fake native C arithmetic tests"

  phase_4_9_0:
    description: "Phase 4.9.0 STM32G4 Debug Detection - Hardware debugger detection validation"
    tests:
      - stm32g4_debug_detection_gt
    timeout: 45s

  phase_4_9_1:
    description: "Phase 4.9.1 IOController Printf Routing - CoreDebug-based automatic routing"
    tests:
      - iocontroller_printf_routing_gt
      - guest_printf_integration
    timeout: 90s

  phase_4_9_2:
    description: "Phase 4.9.2 Golden Triangle Bytecode Infrastructure - ArduinoC guest program execution"
    tests:
      - gpio_pin13_bytecode_phase_4_9_2
      - printf_routing_bytecode_phase_4_9_2
    timeout: 90s

  gpio_platform_test_interface:
    description: "Phase 4.9.1.A GPIO Platform Test Interface validation suite"
    tests:
      - gpio_pin13_golden_triangle
      - gpio_platform_interface_integration
    timeout: 90s

  # Phase 4.9.3 Concierge Architecture Tests
  concierge_gpio_pin13_simple:
    source: test_concierge_gpio_pin13_simple.c
    dependencies: []
    description: "Phase 4.9.3 Simple GPIO test via concierge auto-execution"
    timeout: 45s
    expected_patterns:
      - "CONCIERGE_GPIO_TEST_START"
      - "GPIO_PIN_13_CONFIGURED_OUTPUT"
      - "GPIO_PIN_13_WRITE_HIGH"
      - "GPIO_PIN_13_WRITE_LOW"
      - "CONCIERGE_GPIO_TEST_COMPLETE"
      - "CONCIERGE: Guest program loaded"
      - "CONCIERGE: Guest program execution started"
      - "CONCIERGE: Guest program execution completed"
    hardware_requirements:
      - gpio_pin13
      - concierge_runtime
    category: concierge_gpio_auto_execution
    priority: high
    stability: phase_4_9_3
    notes: "Concierge auto-execution test: 26 instructions, 5 strings"
    platform_test_interface: true
    debugger_required: true
    concierge_test: true
    auto_execution: true
    bytecode_info:
      instruction_count: 26
      string_count: 5
      compilation_method: "phase_4_9_3_concierge_infrastructure"
    concierge_config:
      auto_loader_enabled: true
      page63_flash_required: true
      guest_api_integration: true
      printf_routing_validation: false
      gpio_validation: true
    validation:
      execution_strategy: concierge_auto_execution
      required: true
      authority:
        overall: authoritative
        semihosting: required
        concierge: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 40s
      semihosting_checks:
        - contains: "CONCIERGE_GPIO_TEST_START"
        - contains: "GPIO_PIN_13_CONFIGURED_OUTPUT"
        - contains: "GPIO_PIN_13_WRITE_HIGH"
        - contains: "GPIO_PIN_13_WRITE_LOW"
        - contains: "CONCIERGE_GPIO_TEST_COMPLETE"
        - contains: "CONCIERGE: Guest program loaded"
        - contains: "CONCIERGE: Guest program execution started"
        - contains: "CONCIERGE: Guest program execution completed"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 35s
      concierge_checks:
        - contains: "CONCIERGE: Guest program loaded"
        - contains: "CONCIERGE: Guest program execution started"
        - contains: "CONCIERGE: Guest program execution completed"
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_concierge_metrics: true
        include_both_passes: true

  concierge_printf_routing_simple:
    source: test_concierge_printf_routing_simple.c
    dependencies: []
    description: "Phase 4.9.3 Simple printf routing test via concierge auto-execution"
    timeout: 45s
    expected_patterns:
      - "CONCIERGE_PRINTF_TEST_START"
      - "Testing concierge auto-execution"
      - "Guest program running under concierge management"
      - "Printf routing should work transparently"
      - "CONCIERGE_PRINTF_TEST_COMPLETE"
      - "CONCIERGE: Guest program loaded"
      - "CONCIERGE: Guest program execution started"
      - "CONCIERGE: Guest program execution completed"
    hardware_requirements:
      - concierge_runtime
      - iocontroller_printf
    category: concierge_printf_auto_execution
    priority: high
    stability: phase_4_9_3
    notes: "Concierge auto-execution test: 13 instructions, 5 strings"
    platform_test_interface: true
    debugger_required: true
    concierge_test: true
    auto_execution: true
    bytecode_info:
      instruction_count: 13
      string_count: 5
      compilation_method: "phase_4_9_3_concierge_infrastructure"
    concierge_config:
      auto_loader_enabled: true
      page63_flash_required: true
      guest_api_integration: true
      printf_routing_validation: true
      gpio_validation: false
    validation:
      execution_strategy: concierge_auto_execution
      required: true
      authority:
        overall: authoritative
        semihosting: required
        concierge: required
        memory: optional
        timeout_strategy: fail_graceful
      timeout: 40s
      semihosting_checks:
        - contains: "CONCIERGE_PRINTF_TEST_START"
        - contains: "Testing concierge auto-execution"
        - contains: "Guest program running under concierge management"
        - contains: "Printf routing should work transparently"
        - contains: "CONCIERGE_PRINTF_TEST_COMPLETE"
        - contains: "CONCIERGE: Guest program loaded"
        - contains: "CONCIERGE: Guest program execution started"
        - contains: "CONCIERGE: Guest program execution completed"
        - not_contains: "FAIL"
        - not_contains: "ERROR"
      semihosting_timeout: 35s
      concierge_checks:
        - contains: "CONCIERGE: Guest program loaded"
        - contains: "CONCIERGE: Guest program execution started"
        - contains: "CONCIERGE: Guest program execution completed"
      diagnostics:
        verbosity: verbose
        memory_dump_range: 0x20
        include_peripheral_summary: true
        include_concierge_metrics: true
        include_both_passes: true

  phase_4_9_1_a:
    description: "Phase 4.9.1.A VM Host Startup Integration - GPIO validation"
    tests:
      - gpio_pin13_golden_triangle
      - gpio_platform_interface_integration
    timeout: 90s


  phase_4_9_3:
    description: "Phase 4.9.3 ComponentVM Auto-Execution - Elegant minimal solution"
    tests:
      - vm_auto_execution_golden_triangle
    timeout: 60s

  phase_4_9_4:
    description: "Phase 4.9.4 Host Startup Integration - Unified startup coordination"
    tests:
      - phase_4_9_4_host_startup_coordination
    timeout: 45s


  full_regression:
    description: "Complete regression test suite"
    tests:
      - pc6_led_focused
      - led_basic
      - uart_basic
